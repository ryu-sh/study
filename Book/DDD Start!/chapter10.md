# 이벤트
- 이번장이 제일 어려웠던 부분인거 같다.
- 하지만 좀 더 공부하고 도입해본다면 큰 도움이 있을거 같다.
- 아직 람다랑, ThreadLocal 부분을 잘 모르다 보니 어렵게 다가왔다.
- 이번장은 꼭 예제코드를 보면서 공부해야 한다. 책만 보며 이해가 잘 안될 수 있다.
- 스프링 프레임워크에서 제공하는 이벤트가 있는데 이부분도 한번 보면 좋을 것 같다.

### 이벤트 용도와 장점
- 이벤트는 BOUNDED CONTEXT간의 높은 결합도를 완화 시켜줄 수 있는 좋은 개발 방법이다.
- 주문 취소 후 환불 과정에서 주문이 취소됐지만 환불이 실패할 경우 어떻게 처리를 해야할까로 예시를 들었다.
- 도메인 모델에서 이벤트를 도입학 위해선 아래와 같이 진행한다.
- 이벤트 생성 주체 - 이벤트 디스패처 - 이벤트 핸들러
- 도메인 모델에서 이벤트 주체는 엔티티, 밸류, 도메인 서비스와 같은 도메인 객체이다. 이들 도메인 객체는 도메인 로직을 실행해서 상태가 바뀌면 관련 이벤트를 발생시킨다.
- 이벤트 핸들러는 이벤트 생성 주체가 발생한 이벤트에 반응한다. 이벤트 핸들러는 생성 주체가 발생한 이벤트를 전달받아 이벤트에 담긴 데이터를 이용해서 원하는 기능을 실행한다.
- 이벤트 생성 주체와 이벤트 핸들러를 연결해 주는 것이 이벤트 디스패처이다. 이벤트 생성 주체는 이벤트를 생성해서 디스패처에 이벤트를 전달한다. 이벤트를 전달받은 디스패처는 해당이벤트를 처리할 수 있는 핸들러에 이벤트를 전파한다. 이벤트 디스패처의 구현 방식에 따라 이벤트 생성과 처리를 동기나 비동기로 실행하게 된다.

### 핸들러 디스패치와 핸들러 구현
- 이벤트는 과거에 벌어진 상태 변화나 사건을 의미하므로 이벤트 클래스의 이름을 결정할 때에는 과거 시제를 사용해야 한다는 점만 유의하면 된다.
```
// 이벤트 처리 흐름
1. 이벤트 처리에 필요한 이벤트 핸들러를 생성한다.
2. 이벤트 발생 전에 이벤트 핸들러를 Events.handle() 메서드를 이용해 등록한다.
3. 이벤트를 발생하는 도메인 기능을 실행한다.
4. 도메인은 Events.raise()를 이용해서 이벤트를 발생시킨다.
5. Events.raise()는 등록된 핸들러의 canHandle()을 이용해서 이벤트를 처리할 수
   있는지 확인한다.
6. 핸들러가 이벤트를 처리할 수 있다면 handle() 메서드를 이용해서 이벤트를 처리한다.
7. Events.raise() 실행을 끝내고 리턴한다.
8. 도메인 기능 실행을 끝내고 리턴한다.
9. Events.reset()을 이용해서 ThreadLocal을 초기화한다.
```
- 이부분은 소스코드를 보면서 책을 봐야한다.

### 비동기 이벤트 처리
- 예시의 환불기능에서 만약 외부의 환불기능을 사용한다고 가정했을 때, 외부의 환불기능이 갑자기 느려지면 취소에 해당하는 cancel() 메서드도 함께 느려진다. 시스템의 성능 저하 뿐만 아니라 트랜잭션도 문제가 된다.
- 외부 시스템과의 연동을 동기로 처리할 때 발생하는 성능과 트랜잭션 범위 문제를 해소하는 방법 중 하나가 이벤트를 비동기로 처리하는 것이다.
- 로컬 핸들러를 비동기로 실행하기
  - 동기를 비동기로 실행할 이벤트 핸들러를 처리하는 방식은 ExecutorService를 선언하고 submit을 이용해서 스레드 풀에 핸들러 실행 작업을 등록하는 반면에 동기로 실행할 이벤트 핸들러는 바로 실행하게 한다.
- 메시지 큐를 이용하기
- 이벤트 저장소와 이벤트 포워더 사용하기
- 이벤트 저장소와 이벤트 제공 API 사용하기
