## 클래스 정의
객체의 상태와 행동이 정의된 하나의 클래스로 비슷한 구조를 갖되 상태는 서로 다른 여러 객체를 만들 수 있다. 그렇다면 어떻게 정의해야 할까? 먼저 클래스의 구조를 살펴보자.

- 필드(field) - 필드는 해당 클래스 객체의 상태 속성을 나타내며, 멤버 변수라고도 불린다. 여기서 초기화하는 것을 필드 초기화 또는 명시적 초기화라고 한다.

   - 인스턴스 변수 - 이름에서 알 수 있듯이 인스턴스가 갖는 변수이다. 그렇기에 인스턴스를 생성할 때 만들어진다. 서로 독립적인 값을 갖으므로 heap 영역에 할당되고 gc에 의해 관리된다.
   - 클래스 변수 - 정적을 의미하는 static키워드가 인스턴스 변수 앞에 붙으면 클래스 변수이다. 해당 클래스에서 파생된 모든 인스턴스는 이 변수를 공유한다. 그렇기 때문에 heap 영역이 아닌 static 영역에 할당되고 gc의 관리를 받지 않는다. 또한 public 키워드까지 앞에 붙이면 전역 변수라 볼 수 있다.

- 메서드(method) - 메서드는 해당 객체의 행동을 나타내며, 보통 필드의 값을 조정하는데 쓰인다.

   - 인스턴스 메서드 - 인스턴스 변수와 연관된 작업을 하는 메서드이다. 인스턴스를 통해 호출할 수 있으므로 반드시 먼저 인스턴스를 생성해야 한다.
   - 클래스 메서드 - 정적 메서드라고도 한다. 일반적으로 인스턴스와 관계없는 메서드를 클래스 메서드로 정의한다.
- 생성자(constructor) - 생성자는 객체가 생성된 직후에 클래스의 객체를 초기화하는 데 사용되는 코드 블록이다. 메서드와 달리 리턴 타입이 없으며, 클래스엔 최소 한 개 이상의 생성자가 존재한다.
- 초기화 블록(initializer) - 초기화 블록 내에서는 조건문, 반복문 등을 사용해 명시적 초기화에선 불가능한 초기화를 수행할 수 있다.

   - 클래스 초기화 블록 - 클래스 변수 초기화에 쓰인다.
   - 인스턴스 초기화 블록 - 인스턴스 변수 초기화에 쓰인다.

     클래스 변수 초기화: 기본값 → 명시적 초기화 → 클래스 초기화 블록
     
     인스턴스 변수 초기화: 기본값 → 명시적 초기화 → 인스턴스 초기화 블록 → 생성자

## 접근제어자, 그외

static이나 public같은 키워드를 제어자(modifier)라고 하며, 클래스나 멤버 선언 시 부가적인 의미를 부여한다.

- 접근 제어자 - 접근 제어자는 해당 클래스 또는 멤버를 정해진 범위에서만 접근할 수 있도록 통제하는 역할을 한다. 클래스는 public과 default밖에 쓸 수 없다. 범위는 다음과 같다. 참고로 default는 아무것도 덧붙이지 않았을 때를 의미한다.

![](https://jeeneee.dev/static/f696bef2cc0494a8ba68c72411b52879/cad6c/access-modifier.png)

- static - 변수, 메서드는 객체가 아닌 클래스에 속한다.
- final

   - 클래스 앞에 붙으면 해당 클래스는 상속될 수 없다.
   - 변수 또는 메서드 앞에 붙으면 수정되거나 오버라이딩 될 수 없다.
- abstract

   - 클래스 앞에 붙으면 추상 클래스가 되어 객체 생성이 불가하고, 접근을 위해선 상속받아야 한다.
   - 변수 앞에 지정할 수 없다. 메서드 앞에 붙는 경우는 오직 추상 클래스 내에서의 메서드밖에 없으며 해당 메서드는 선언부만 존재하고 구현부는 상속한 클래스 내 메서드에 의해 구현되어야 한다. 상속과 관련된 내용은 6주차에 다룰 예정이다.
- transient - 변수 또는 메서드가 포함된 객체를 직렬화할 때 해당 내용은 무시된다.
- synchronized - 메서드는 한 번에 하나의 쓰레드에 의해서만 접근 가능하다.
- volatile - 해당 변수의 조작에 CPU 캐시가 쓰이지 않고 항상 메인 메모리로부터 읽힌다.

## 메서드 오버라이딩
- 조상클래스로부터 상속받은 메서드의 내용을 변경하는 것을 오버라이딩이라고 한다. 상속받은 메서드를 그대로 사용하기도 하지만, 자손 클래스 자신에 맞게 변경해야하는 경우가 많다. 이럴 때 조상의 메서드를 오버라이딩한다.
- 접근 제어자는 조상 클래스의 메서드보다 좁은 범위로 변경할 수 없다.
   - 만일 조상 클래스에 정의된 메서드의 접근 제어자가 protected라면, 이를 오버라이딩하는 자손 클래스의 메서드는 접근 제어자가 protected나 public이어야 한다. 대부분의 경우 같은 범위의 접근 제어자를 사용한다.
- 조상 클래스의 메서드보다 많은 수의 예외를 선언할 수 없다.

- 오버로딩(overloading) 기존에 없는 새로운 메서드를 정의하는 것(new)
- 오버라이딩(overriding) 상속받은 메서드의 내용을 변경하는 것(change, modify)

```java
class Parent {
        void parentMethod() { }
    }

class Child extends Parent {
  void parentMethod() { }         // 오버라이딩
  void parentMethod(int i) { }    // 오버로딩

  void childMethod() { }
  void childMethod(int i) { }     // 오버로딩
}
```

## 메소드 디스패치 (Dynamic Method Dispatch)
 - 메소드 디스패치(method dispatch)는 어떤 메소드를 호출할지 결정하여 실행시키는 과정을 말한다. 이 과정은 static(정적)과 dynamic(동적)이 있다.
1. static method dispatch
 - 컴파일 시점에서, 컴파일러가 특정 메소드를 호출할 것이라고 명확하게 알고있는 경우이다.
```java
class Dispatch {
        static class Service {
            void run() {
                System.out.println("run");
            }

            void run(String msg) {
                System.out.println(msg);
            }
        }

        public static void main(String[] args) {
            new Service().run();
        }
    }
```
2. dynamic method dispatch
 - 정적 디스패치와 반대로 컴파일러가 어떤 메소드를 호출하는지 모르는 경우이다. 동적 디스패치는 호출할 메서드를 런타임 시점에서 결정한다.(MyService1 일지, MyService2일지 컴파일 시점에는 모름)
```java
 class Dispatch {
        static abstract class Service {
            abstract void run();
        }

        static class MyService1 extends Service {
            @Override
            void run() {
                System.out.println("1");
            }
        }

        static class MyService2 extends Service {
            @Override
            void run() {
                System.out.println("2");
            }
        }

        public static void main(String[] args) {
            Service srv = new MyService1();
            srv.run();
        }
    }
```

## 추상클래스와 인터페이스 차이점
- 추상클래스의 목적은 상속을 받아서 기능을 확장시키는 것(부모의 유전자를 물려받는다.)
- 인터페이스의 목적은 구현하는 모든 클래스에 대해 특정한 메서드가 반드시 존재하도록 강제하는 역할 (구현한 객체들에 대해서 동일한 동작을 약속하기 위해 존재)

## final
- final은 ‘마지막의’ 또는 ‘변경될 수 없는’의 의미를 가지고 있으며 거의 모든 대상에 사용될 수 있다.
- 변수에 사용되면 값을 변경할 수 없는 상수가 되며, 메서드에 사용되면 오버라이딩을 할 수 없게 되고 클래스에 사용되면 자신을 확장하는 자손클래스를 정의하지 못하게 된다.
