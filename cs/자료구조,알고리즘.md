# 큐 / 스택

### 스택

- 원소들의 삽입과 삭제가 리스트의 한쪽 끝에서만 수행되는 자료구조이다. 
- 후입선출 LIFO 방식을 따른다.
- 자바에서 제공하고 있는 Stack 라이브러리는 'Vector' 클래스를 상속받아 구현(스레드 세이프)
- 주요 기능
  - pop(): 스택에서 가장 위에 있는 항목을 제거한다.
    push(item): item 하나를 스택의 가장 윗 부분에 추가한다.
    peek(): 스택의 가장 위에 있는 항목을 반환한다.
- 사용 사례
  - 재귀 알고리즘
    재귀적으로 함수를 호출해야 하는 경우에 임시 데이터를 스택에 넣어준다.
    재귀함수를 빠져 나와 퇴각 검색(backtrack)을 할 때는 스택에 넣어 두었던 임시 데이터를 빼 줘야 한다.
    스택은 이런 일련의 행위를 직관적으로 가능하게 해 준다.
    또한 스택은 재귀 알고리즘을 반복적 형태(iterative)를 통해서 구현할 수 있게 해준다.
  - 깊이 우선 탐색(DFS) 구현
  - 웹 브라우저 방문기록 (뒤로가기)
  - 실행 취소 (undo)
  - 역순 문자열 만들기



### 큐

- 리스트의 한쪽 끝에서는 원소들이 삭제되고, 반대쪽 끝에서는 삽입만 가능하게 만든 순서화된 자료구조이다. 
- 선입선출 FIFO 방식을 따른다. 
- 그래프의 너비 우선 탐색(BFS)에서 사용
- 주요 기능
  - add(item), offer(item): item을 큐의 끝부분에 추가한다. (enqueue)
  - remove(), poll(): 큐에서 가장 위에 있는 항목을 제거한다.
  - peek(): 큐에서 가장 위에 있는 항목을 반환한다.
- 사용 사례
  - 너비 우선 탐색(BFS) 구현
    - 처리해야 할 노드의 리스트를 저장하는 용도로 큐(Queue)를 사용한다.
      노드를 하나 처리할 때마다 해당 노드와 인접한 노드들을 큐에 다시 저장한다.
      노드를 접근한 순서대로 처리할 수 있다.
  - 선입선출이 필요한 대기열 (티켓 카운터)
  - 콜센터 고객 대기시간
  - 프린터의 출력 처리



### 덱

- Deque는 Queue와 Stack이 혼합된 개념
- 앞과 뒤 양쪽에서 Push와 Pop연산 가능



### 큐와 스택의 구현

- 큐(Queue): Array로 구현하면 poll 연산 이후 객체를 앞당기는 작업이 필요하다. 하지만 List로 구현하면 객체 1개만 제거하면 되므로 삽입 및 삭제가 용이한 LinkedList로 구현하는 것이 좋다.
- 스택(Stack): List로 구현하면 객체를 제거하는 작업이 필요하다. 하지만 Array로 구현하면 삭제할 필요 없이 index를 줄이고 초기화만 하면 되므로, Array로 구현하는 것이 좋다.



### 우선순위 큐와 내부 구조 및 시간복잡도

- 우선순위큐는 가장 우선순위가 높은 데이터를 먼저 꺼내기 위해 고안된 자료구조
- 우선순위 큐를 구현하기 위해서 일반적으로 힙을 사용한다. 
- 힙은 완전이진트리를 통해서 구현되었기 때문에 우선순위 큐의 시간복잡도는 O(logn)이다.



# 트리

### 트리

- 정점과 간선을 이용해 사이클을 이루지 않도록 구성한 Graph의 특수한 형태로, 계층이 있는 데이터를 표현하기에 적합하다.
- 트리는 하나의 루트 노드를 갖는다.
- 루트 노드는 0개 이상의 자식 노드를 갖고 있다.
- 그 자식 노드 또한 0개 이상의 자식 노드를 갖고 있고, 이는 반복적으로 정의된다



### 이진트리

- 각 노드가 최대 두 개의 자식을 갖는 트리
- 모든 트리가 이진 트리는 아니다.



### 트리 순회

![img](https://miro.medium.com/max/2924/1*4IIjmCbo2SnmA_Sy5tYQew.png)

1. 전위 순회 (Pre-order Traversal) : 루트, 왼쪽 자식, 오른쪽 자식 순서로 방문하는 순서 방법이다.
2. 중위 순회 (In-order Traversal) : 왼쪽 자식, 루트, 오른쪽 자식 순서로 방문하는 순회 방법이다. 이진 탐색 트리를 중위 순회하면 정렬된 결과를 얻을 수 있다.
3. 후위 순회 (Post-order Traversal) : 왼쪽 자식, 오른쪽 자식, 루트 순서로 방문하는 순서 방법이다.
4. 레벨 순서 순회 (Level-order Traversal) : 너비 우선 순회 (BFS) 라고도 한다. 위의 세 가지 방법은 스택을 활용하여 구현할 수 있는 반면, 레벨 순서 순회는 큐를 활용해 구현한다.



### 이진 탐색 트리

- 각 노드의 왼쪽 서브트리에는 해당 노드의 값보다 작은 값을 지닌 노드들로 이루어져 있다.
- 각 노드의 오른쪽 서브트리에는 해당 노드의 값보다 큰 값을 지닌 노드들로 이루어져 있다.
- 중복된 노드가 없어야 한다.

![img](https://t1.daumcdn.net/cfile/tistory/99ACAF335989659B19)

- 이진탐색트리를 순회할 때는 중위순회(inorder) 방식을 쓴다. 모든 값들을 정렬된 순서로 읽을 수 있다.
- 평균적으로 O(logN)의 삽입, 삭제, 검색 연산속도를 가진다.
- 트리의 높이에 의해 수행시간이 결정되는 구조이기에, 균형이 맞지 않아 계산복잡성이 O(n)이 될 수 있다.



### AVL 트리

- 트리 깊이의 균형을 맞출 수 있다
- 트리의 깊이가 균형이 맞게 된다면 이진 탐색 알고리즘의 속도와 비슷해진다. O(logN)
- 왼쪽 서브트리 높이와 오른쪽 서브트리 높이의 차가 1이하

 

### 레드 블랙 트리

- 트리 깊이의 균형을 맞출 수 있다
- 트리의 깊이가 균형이 맞게 된다면 이진 탐색 알고리즘의 속도와 비슷해진다. O(logN)

- 레드블랙 트리는 모든 노드를 빨간색 또는 검은색으로 구분한다. 
- 그리고 연결된 노드들은 색이 중복되지 않도록 관리된다.
- 저바의 TreeMap, TreeSet이 사용



### B 트리 / B+트리

- B 트리
  - 이진 탐색 트리와 유사하지만, 한 노드 당 자식 노드가 2개 이상 가능하다.
  - 리프 노드, 브랜치 노드 모두 데이터 저장 가능
  - 균형 트리이다. 하지만 테이블 갱신(INSERT/UPDATE/DELETE)의 반복을 통해 서서히 균형이 깨지고, 성능도 악화된다.
  - 어느 정도 자동으로 균형을 회복하는 기능이 있지만, 갱신 빈도가 높은 테이블에 작성되는 인덱스 같은 경우 인덱스 재구성을 해서 트리의 균형을 되찾는 작업이 필요하다.

- B+ 트리
  - B 트리와 달리  브랜치 노드에 key만 담아두고, data는 담지 않는다. 
  - 오직 리프 노드에만 key와 data를 저장하고, 리프 노드끼리 Linked list로 연결되어 있다. 
  - 리프 노드를 제외하고 데이터를 담아두지 않기 때문에 메모리를 더 확보함으로써 더 많은 key들을 수용할 수 있다. 
  - 하나의 노드에 더 많은 key들을 담을 수 있기에 트리의 높이는 B 트리 보다 낮아진다.(cache hit를 높일 수 있음)



### 완전 이진 트리  / 포화 이진 트리

- 완전 이진 트리

  ![img](https://gmlwjd9405.github.io/images/data-structure-tree/Complete-Binary-Tree.png)

  - 트리의 모든 높이에서 노드가 꽉 차 있는 이진 트리.
  - 마지막 레벨을 제외하고 모든 레벨이 완전히 채워져 있다.
  - 마지막 레벨은 꽉 차 있지 않아도 되지만 노드가 왼쪽에서 오른쪽으로 채워져야 한다.

- 포화 이진 트리

  ![img](https://gmlwjd9405.github.io/images/data-structure-tree/Perfect-Binary-Tree.png)

  - 모든 말단 노드는 같은 높이에 있어야 하며, 마지막 단계에서 노드의 개수가 최대가 되어야 한다.
  - 모든 내부 노드가 두 개의 자식 노드를 가진다.
  - 모든 말단 노드가 동일한 깊이 또는 레벨을 갖는다.



### 힙

![img](https://miro.medium.com/max/3378/1*lkrk6gtrr9nYnd5WkLsPwg.png)

- 우선 순위 큐 개념에 사용

- 항상 자식은 두개밖에 없고, leaf의 가장 왼쪽부터 채운다.

- 완전 이진 트리의 일종으로 최대 힙 트리, 최소 힙 트리로 나뉜다. 

- 최대 힙은 최대 값을 루트로 하여 부모 노드의 값이 항상 자식 노드의 값보다 큰 트리 구조이며, 최소 힙은 최소 값을 루트로 하여 부모 노드의 값이 항상 자식 노드의 값보다 작은 트리 구조다.

- 힙 트리에서는 중복된 값을 허용한다. (이진 탐색 트리에서는 중복된 값을 허용하지 않는다.)

- 힙의 구현

  ![img](https://gmlwjd9405.github.io/images/data-structure-heap/heap-index-parent-child.png)

  - 힙을 저장하는 표준적인 자료구조는 배열 이다.
  - 구현을 쉽게 하기 위하여 배열의 첫 번째 인덱스인 0은 사용되지 않는다.
  - 특정 위치의 노드 번호는 새로운 노드가 추가되어도 변하지 않는다.
    - 예를 들어 루트 노드의 오른쪽 노드의 번호는 항상 3이다.
  - 힙에서의 부모 노드와 자식 노드의 관계
    - 왼쪽 자식의 인덱스 = (부모의 인덱스) * 2
    - 오른쪽 자식의 인덱스 = (부모의 인덱스) * 2 + 1
    - 부모의 인덱스 = (자식의 인덱스) / 2

- 힙의 삽입

  - 힙에 새로운 요소가 들어오면, 일단 새로운 노드를 힙의 마지막 노드에 이어서 삽입한다.
  - 새로운 노드를 부모 노드들과 교환해서 힙의 성질을 만족시킨다.
    ![img](https://gmlwjd9405.github.io/images/data-structure-heap/maxheap-insertion.png)

- 힙의 삭제
  - 최대 힙에서 최댓값은 루트 노드이므로 루트 노드가 삭제된다.
  - 최대 힙에서 삭제 연산은 최댓값을 가진 요소를 삭제하는 것이다.
  - 삭제된 루트 노드에는 힙의 마지막 노드를 가져온다.
  - 힙을 재구성한다.
    ![img](https://gmlwjd9405.github.io/images/data-structure-heap/maxheap-delete.png)





# Graph

- To-do



# 해시

![img](https://blog.kakaocdn.net/dn/b1zOw1/btqL6HAW7jy/jpBA5pPkQFnfiZcPLakg00/img.png)

- 검색 성능은 해시 함수의 성능과 해시 테이블의 크기에 좌우된다.
- 충돌이 없거나 적으면 O(1)의 상수 시간에 가까워지고, 충돌이 발생하면 할수록 성능은 점점 O(n)에 가까워진다.

- 해시 테이블은 키(Key), 해시함수(Hash Function), 해시(Hash), 값(value), 저장소(Bucket, Slot)로 이루어져 있다.
  - 키(key) : 고유한 값이며, 해시 함수의 input이 된다. 다양한 길이의 값이 될 수 있다. 이 상태로 최종 저장소에 저장이 되면 다양한 길이 만큼의 저장소를 구성해 두어야 하기 때문에 해시 함수로 값을 바꾸어 저장이 되어야 공간의 효율성을 추구할 수 있다.
  - 해시함수(Hash Function) : 키(key)를 해시(hash)로 바꿔주는 역할을 한다. 다양한 길이를 가지고 있는 키(key)를 일정한 길이를 가지는 해시로 변경하여 저장소를 효율적으로 운영할 수 있도록 도와준다. 다만, 서로 다른 키(key)가 같은 해시(hash)가 되는 경우를 해시 충돌이라고 하는데, 해시 충돌을 일으키는 확률을 최대한 줄이는 함수를 만드는 것이 중요하다.
    - Division Method 해시 함수 : hash(key)%array_length로 배열의 인덱스 구현
  - 해시(Hash) : 해시 함수(Hash Function)의 결과물이며, 저장소(bucket, slot)에서 값(value)과 매칭되어 저장된다.
  - 값(Value) : 저장소(bucket, slot)에 최종적으로 저장되는 값으로 키와 매칭되어 저장, 삭제, 검색, 접근이 가능해야 한다.



### 해시 충돌 방지

- 해시충돌 : 해싱된 키(Hash Key)가 중복되어 해당 버킷(Bucket)에 이미 레코드가 존재하는 현상
- 체이닝 방식
  - 충돌이 발생했을 때 이를 동일한 버킷(Bucket)에 저장하는데 이를 링크드리스트 형태로 저장하는 방법을 말한다.
  - JDK8에서는 슬롯의 갯수가 8개 이하일 경우 연결 리스트(Linked List)를 사용하며 그 이상의 경우는 트리(Tree) 구조를 사용하여 검색의 효율을 높이고 있다.



# List

- 데이터(객체)를 순서대로 저장하는 자료 구조
- 데이터 중복 가능
- 인덱스로 접근 가능(조회, 수정, 삭제)



### ArrayList

- 데이터마다 Index가 존재해 데이터 조회 기능 우수
- 중간 위치에 데이터를 삽입, 삭제할 경우 인덱스가 밀리기 때문에 추가, 삭제가 빈번한 자료에는 적합하지 않음

### LinkedList

- 양방향 포인터 구조
- index로 값을 저장하는것이 아니라 노드들의 주소를 값을 가지고 있기 때문에 객체의 삽입/삭제가 ArrayList보다 빠르다
- 특정 위치의 데이터를 조회하려면 순차적으로 읽어야 되기 때문에 불리하다.

### Vector

- ArrayList의 구형버전
- 모든 메소드가 동기화 되어 있음



### LinkedList와 ArrayList 차이

ArrayList는 데이터들이 순서대로 늘어선 배열의 형식을 취하고 있지만, LinkedList는 자료의 주소값으로 서로 연결된 형식을 가지고 있다. 이러한 구조에 의해 둘은 각각의 장단점을 가지고 있다.

### ArrayList

- 원하는 데이터에 무작위로 접근할 수 있다.
- 리스트의 크기가 제한되어 있으며, 리스트의 크기를 재조정하는 것은 많은 연산이 필요하다.
- 데이터의 추가/삭제를 위해서는 임시 배열을 생성하여 복제하고 있어 시간이 오래 걸린다.

### LinkedList

- 리스트의 크기에 영향 없이 데이터를 추가할 수 있다.
- 데이터를 추가하기 위해 새로운 노드를 생성하여 연결하므로 추가/삭제 연산이 빠르다.
- 무작위 접근이 불가능하며, 순차 접근만이 가능하다.



# SET

- 중복되지 않는 유일한 데이터(객체)를 저장하는 자료 구조

### HashSet

- 값이 저장된 순서를 보장하지 않음
- Set 중에 가장 성능이 좋음

### LinkedHashSet

- LinkedList를 이용해 저장된 순서를 보장

### TreeSet

- 정렬방법을 지정할 수 있음
- 정렬된 순서대로 저장
- Red-Black Tree



# Map

- 키(key)와 값(value)으로 구성된 객체를 저장하는 자료 구조
- 키는 중복으로 저장할 수 없고 값은 중복으로 저장할 수 있음

### HashMap

- 순서를 보장하지 않음
- 키와 값으로  null 허용

### HashTable

- HashMap보다 느리지만 동기화 지원
- 키와 값으로 null 허용하지 않음

### LinkedHashMap

- 기본적으로 HashMap을 상속받아 HashMap과 매우 흡사
- LinkedList를 이용해 저장된 순서를 보장

### TreeMap

- 정렬방법을 지정할 수 있음
- 정렬된 순서대로 저장
- Red-Black Tree

### ConcurrentHashMap

- 동기화 지원
- 키와 값으로 null 허용하지 않음
- 내부적으로 여러 개의 세그먼트를 두고 각 세그먼트마다 별도의 락을 걸기 때문에 HashTable보다 성능이 우수하다.
  - 기본적으로 16개의 세그먼트로 나눠서 내부 데이터를 관리





------



# 정렬

![img](https://user-images.githubusercontent.com/58316983/86914110-b0769400-c15a-11ea-8212-bcda25b87976.png)

### 버블 정렬 (Bubble sort)

![img](https://cdn-images-1.medium.com/max/1600/1*ZQmdM7My9QIhvxj98hrweg.gif)

- 버블정렬은 두 인접한 원소를 검사하여 정렬하는 방법
- 시간 복잡도는 느리지만 코드가 단순하다
- 배열 전체를 순회하며 비교하기 때문에 시간복잡도는 O(n²)



### 선택 정렬 (Selection sort)

![img](https://cdn-images-1.medium.com/max/1600/1*to7gYwi5_bkZhx-1kSB0Lg.gif)

- 배열의 가장 작은 값을 가지는 인덱스를 찾아서 가장 작은 값을 앞에서부터 채워나가면서 정렬하는 방식.

- for loop 2번을 통해 배열을 훑고, swap하는 방식으로 시간복잡도는 O(n²)

  

### 삽입 정렬 (Insertion sort)

![img](https://cdn-images-1.medium.com/max/1600/1*IK3Q4NBRLthllMINV3OxpQ.gif)

- 최소값을 찾아서 이하 배열들의 원소와 비교하여 자신이 위치해야할 곳을 찾아 삽입해나가며 정렬하는 방식이다.
- for loop 혹은 while loop를 2중첩으로 구현되어 시간복잡도는 O(n²)
- 이미 정렬이 되어있다면 O(n)의 시간복잡도



### 병합 정렬 (Merge sort)

![img](https://cdn-images-1.medium.com/max/1600/1*Uvs7CK1oew0pVckcuxr_qA.gif)

- 배열을 반씩 쪼개서 하나의 원소를 가진 배열로 만든 후 비교를 통해 각 배열을 정렬하여 병합하여 최종 정렬된 배열을 구하는 정렬방식이다.
- 배열을 반씩 쪼개며 정렬을 하고 다시 그것을 병합하는 방법으로 시간복잡도는 O(nlogn)



### 퀵 정렬 (Quick sort)

![img](https://cdn-images-1.medium.com/max/1600/1*wwCw5TzLd79k2WQ6YVsQVw.gif)

- 퀵정렬은 real-world 데이터에서 빠르다고 알려져 있어 가장 많이 쓰는 정렬 알고리즘이다.
- 퀵정렬은 pivot(기준)을 선정하여 pivot을 기준으로 좌측과 우측으로 pivot보다 작은값은 왼쪽 pivot보다 큰값은 오른쪽으로 재배치를 하고 계속하여 분할하여 정렬하는 알고리즘이다.
- 일반적으로 O(nlogn)의 시간복잡도를 가진다.

- 피벗으로 어떤 값을 잡는지에 따라 효율이 달라진다. 최악의 경우 시간복잡도가 O(n²)가 되는데, 피벗을 최솟값이나 최댓값으로 계속해서 잡게 되는 경우에 그렇다.



### 팀 정렬 (Tim sort)

- 병합정렬 + 삽입정렬
- 병합정렬은 원소의 개수가 적을 때 오버헤드가 발생하기 때문에 파티션 크기가 특정 값(보통 16 또는 32) 이하일 때 삽입정렬을 사용한다.





# DFS / BFS

### 깊이 우선 탐색 (DFS, Depth-First Search)



![img](https://blog.kakaocdn.net/dn/xC9Vq/btqB8n5A25K/GyOf4iwqu8euOyhwtFuyj1/img.gif)

- 최대한 깊이 내려간 뒤, 더이상 깊이 갈 곳이 없을 경우 옆으로 이동
- 루트 노드(혹은 다른 임의의 노드)에서 시작해서 다음 분기(branch)로 넘어가기 전에 해당 분기를 완벽하게 탐색하는 방식

- 모든 노드를 방문하고자 하는 경우에 이 방법을 선택함

- 깊이 우선 탐색(DFS)이 너비 우선 탐색(BFS)보다 좀 더 간단함

- 검색 속도 자체는 너비 우선 탐색(BFS)에 비해서 느림



### 너비 우선 탐색 (BFS, Breadth-First Search)

![img](https://blog.kakaocdn.net/dn/c305k7/btqB5E2hI4r/ea7vFo08tkDYo4c8wkfVok/img.gif)

- 최대한 넓게 이동한 다음, 더 이상 갈 수 없을 때 아래로 이동
- 루트 노드(혹은 다른 임의의 노드)에서 시작해서 인접한 노드를 먼저  탐색하는 방법
- 시작 정점으로부터 가까운 정점을 먼저 방문하고 멀리 떨어져 있는 정점을 나중에 방문하는 순회 방법
- 미로 찾기 등 최단거리를 구해야 할 경우, BFS가 유리
- 검색 대상의 규모가 크지 않고, 검색 시작 지점으로부터 원하는 대상이 별로 멀지 않다면 BFS



### 깊이 우선 탐색(DFS) 과 너비 우선 탐색(BFS) 비교

| **DFS(깊이우선탐색)**                             | **BFS(너비우선탐색)**                   |
| ------------------------------------------------- | --------------------------------------- |
| 현재 정점에서 갈 수 있는 점들까지 들어가면서 탐색 | 현재 정점에 연결된 가까운 점들부터 탐색 |
| 스택 또는 재귀함수로 구현                         | 큐를 이용해서 구현                      |





# 동적계획법(Dynamic Programming)





# 탐욕법(Greedy)