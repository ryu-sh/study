# DB

### 인덱스 원리

- B-TREE 인덱스

  - 주로 데이터의 값의 종류가 많고 동일한 데이터가 적을 경우에 사용
  - UNIQUE INDEX - 지정한 컬럼으로 생성한 인덱스의 해당 컬럼 데이터가 중복으로 들어갈 수 없다.

  - Non UNIQUE INDEX - 중복된 컬럼이 들어가야하는 테이블의 경우 생성

  - Function Based INDEX

  - DESCENDING INDEX

  - 결합 인덱스 - 두 개 이상의 컬럼을 합쳐 INDEX 생성


- BITMAP
  - 데이터 값의 종류가 적고, 동일한 데이터가 많을 경우 사용



### 인덱스 종류(MySQL)

Clustered Index

- 데이터가 정렬된(PK 또는 UNIQUE NOT NULL 컬럼을 기준으로 오름차순) 상태(유지)로 저장
- 테이블 당 한 개만 생성
- 제약조건 PRIMARY KEY에 의해 자동으로 생성

Secondary Index

- 테이블에 여러개의 보조 인덱스를 생성할 수 있음
- 제약조건 UNIQUE에 의해 자동으로 생성
- 별도의 인덱스가 생성되지만, 원본 데이터는 변경되지 않음



### DB 정규화

1. 제1정규형: 모든 속성 값이 원자 값을 갖도록 분해한다.
2. 제2정규형: 제1정규형을 만족하고, 기본키가 아닌 속성이 기본키에 완전 함수 종속이도록 분해한다.
   (여기서 완전함수 종속이란 기본키의 부분집합이 다른 값을 결정하지 않는 것을 의미한다.)
3. 제3정규형: 제2정규형을 만족하고, 기본키가 아닌 속성이 기본키에 직접 종속(비이행적 종속)하도록 분해한다.
   (여기서 이행적 종속이란 A->B->C가 성립하는 것으로, 이를 A,B와 B,C로 분해하는 것이 제3정규형이다.)



### 트랜잭션의 ACID

- 원자성(Atomicity): 트랜잭션에 포함된 작업은 전부 수행되거나 전부 수행되지 않아야 한다.
- 일관성(Consistency): 트랜잭션을 수행하기 전이나 후나 데이터베이스는 항상 일관된 상태를 유지해야 한다.
- 고립성(Isolation): 수행 중인 트랜잭션에 다른 트랜잭션이 끼어들어 변경중인 데이터 값을 훼손하지 않아야한다.
- 지속성(Durability): 수행을 성공적으로 완료한 트랜잭션은 변경한 데이터를 영구히 저장해야 한다.



### DB 락의 종류 

- 공유락(LS, Shared Lock)
  - 데이터를 읽을 때 사용되어지는 Lock. 이런 공유 Lock은 공유 Lock 끼리는 동시에 접근이 가능
- 베타락(LX, Exclusive Lock)
  - 데이터를 변경하고자 할 때 사용되며, 트랜잭션이 완료될 때까지 유지된다. 
  - Lock이 해제될 때까지 다른 트랜잭션(읽기 포함)은 해당 리소스에 접근할 수 없습니다.



### 블로킹(Blocking)

블로킹은 Lock간(베타 - 베타, 베타 - 공유)의 경합이 발생하여 특정 Transaction이 작업을 진행하지 못하고 멈춰선 상태



### 교착상태(DeadLock)

교착상태는 두 트랜잭션이 각각 Lock을 설정하고 다음 서로의 Lock에 접근하여 값을 얻어오려고 할 때 이미 각각의 트랜잭션에 의해 Lock이 설정되어 있기 때문에 양쪽 트랜잭션 모두 영원히 처리가 되지않게 되는 상태



### Merge



### Join



### 클러스터링 / 리플리케이션

- 클러스터링

  - 동기 방식으로 노드들 간의 데이터를 동기화

  - 장점
    노드들 간의 데이터를 동기화하여 항상 일관성있는 데이터를 얻을 수 있다.
    1개의 노드가 죽어도 다른 노드가 살아 있어 시스템을 계속 장애없이 운영할 수 있다.
  - 단점
    여러 노드들 간의 데이터를 동기화하는 시간이 필요하므로 Replication에 비해 쓰기 성능이 떨어진다.
    장애가 전파된 경우 처리가 까다로우며, 데이터 동기화에 의해 스케일링에 한계가 있다.

- 리플리케이션
  - 비동기 방식으로 노드들 간의 데이터를 동기화
  - 장점
    DB 요청의 60~80% 정도가 읽기 작업이기 때문에 Replication만으로도 충분히 성능을 높일 수 있다.
    비동기 방식으로 운영되어 지연 시간이 거의 없다.
  - 단점
    노드들 간의 데이터 동기화가 보장되지 않아 일관성있는 데이터를 얻지 못할 수 있다.
    Master 노드가 다운되면 복구 및 대처가 까다롭다.






### 힌트

- 힌트란 SQL을 튜닝하기 위한 지시구문입니다. 

- 옵티마이저가 최적의 계획으로 SQL문을 처리하지 못하는 경우에 개발자가 직접 최적의 실행 계획을 제공하는 것. 

- 힌트는 아래와 같이 SELECT 다음에 작성할 수 있으며, INDEX, PARALLEL 등 다양한 힌트절이 있다.

  - ```
    # 사용가능한 힌트절: PARALLE, INDEX, FULL ... 
    SELECT /*+ [힌트절] */
    ```



### 데이터베이스 튜닝과 방법 ]

- 튜닝은 DB 설계 튜닝 -> DBMS 튜닝 > SQL 튜닝의 단계로 진행할 수 있다.

![img](https://blog.kakaocdn.net/dn/NiaXW/btqKTGpbAfI/CxqbNtEXQvIE1490N8mm6k/img.png)

